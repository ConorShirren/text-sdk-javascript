/**
 * Bulk SMS API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://gw.cmtelecom.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

/**
* Authentication
*/
export class Authentication {
    /**
    * Required: This is the product token for authentication. Visit https://gateway.cmtelecom.com to retrieve your product token.   Example: 00000000-0000-0000-0000-000000000000'
    */
    'productToken': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "productToken",
            "baseName": "productToken",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Authentication.attributeTypeMap;
    }
}

/**
* The message
*/
export class Message {
    /**
    * Required. This is the sender name. The maximum length is 11 alphanumerical characters or 16 digits. Example: 'CM Telecom'
    */
    'from': string;
    /**
    * Required. This contains the message text.
    */
    'body': MessageBody;
    /**
    * To send messages longer than 160 characters you need to send them as multipart message (also called concatenated messages). We will cut the message into more smaller messages and the phone will paste them together again. You will need to add a minimum and maximum of message parts using this parameter and {CM.Sms.Server.HttpMTGatewayDocsWebsite.Models.Message.MaximumNumberOfMessageParts}
    */
    'minimumNumberOfMessageParts': number;
    /**
    * To send messages longer than 160 characters you need to send them as multipart message (also called concatenated messages). We will cut the message into more smaller messages and the phone will paste them together again. You will need to add a minimum and maximum of message parts using this parameter and {CM.Sms.Server.HttpMTGatewayDocsWebsite.Models.Message.MinimumNumberOfMessageParts}
    */
    'maximumNumberOfMessageParts': number;
    /**
    * Here you can include your message reference. This information will be returned in a status report so you can match the message and it's status. Restrictions: 1 - 32 alphanumeric characters.
    */
    'reference': string;
    /**
    * Required. This is the destination mobile number.   Restrictions: this value should be in international format. A single mobile number per request. Example: '00447911123456'
    */
    'to': Array<Recipient>;
    /**
    * The custom grouping field is an optional field that can be used to tag messages. These tags will be used by other CM products, like the Transactions API. Despite not being immediately visible to you yet, custom groupings can already be assigned.  Applying custom grouping names to messages helps filter your messages.With up to three levels of custom grouping fields that can be set, subsets of messages can be further broken down. The custom grouping name can be up to 100 characters of your choosing.  It’s recommended to limit the number of unique custom groupings to 1000. Please contact support in case you would like to exceed this number.
    */
    'customGrouping': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "from",
            "baseName": "from",
            "type": "string"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "MessageBody"
        },
        {
            "name": "minimumNumberOfMessageParts",
            "baseName": "minimumNumberOfMessageParts",
            "type": "number"
        },
        {
            "name": "maximumNumberOfMessageParts",
            "baseName": "maximumNumberOfMessageParts",
            "type": "number"
        },
        {
            "name": "reference",
            "baseName": "reference",
            "type": "string"
        },
        {
            "name": "to",
            "baseName": "to",
            "type": "Array<Recipient>"
        },
        {
            "name": "customGrouping",
            "baseName": "customGrouping",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Message.attributeTypeMap;
    }
}

/**
* Contains the body of the message.
*/
export class MessageBody {
    /**
    * Required. This is the message text.   For GSM7-encoded messages 1 message can contain up to 160 characters, for multipart messages, 1 message can contain up to 153 characters (the other bytes are used to define the multipart messages)    For Unicode-encoded messages 1 message can contain up to 70 characters, for multipart messages, 1 message can contain up to 66 characters per message    Unicode messages are sent using UTF-16, so they usually will be 2 bytes long (and certain characters will be send as multiple characters, but I hope we don’t need to discuss that here).     In theory a message can contain 255 message parts, so in theory the maximum length is 39.015. In practice we advise to limit the amount of parts to 8, so either 1224 or 528 characters
    */
    'content': string;
    /**
    * It possible to let our gateway do the encoding detection for you, by setting the type to \"AUTO\"  In case it detects characters that are not part of the GSM character set, the message will be delivered as Unicode.   Any existing DCS value will be ignored.   If the message contains more than 70 characters in Unicode format it will be split into a multipart message.   You can limit the number of parts by setting the maximum number of message parts (see also the section on Multipart below).
    */
    'type': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MessageBody.attributeTypeMap;
    }
}

/**
* Envelope containing messages and authentication
*/
export class MessageEnvelope {
    'messages': Messages;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "messages",
            "baseName": "messages",
            "type": "Messages"
        }    ];

    static getAttributeTypeMap() {
        return MessageEnvelope.attributeTypeMap;
    }
}

/**
* Response for an individual message
*/
export class MessageResponse {
    /**
    * Maps to the 'to' of the request
    */
    'to': string;
    /**
    * The status of the message, usually either \"Accepted\" or \"Rejected\"
    */
    'status': string;
    /**
    * Optional: If a reference was supplied in the request, it is returned here.
    */
    'reference': string;
    /**
    * The number of message parts that are sent
    */
    'parts': number;
    /**
    * Optional: Human readable details about this message.
    */
    'messageDetails': string;
    /**
    * The error code, see https://docs.cmtelecom.com/bulk-sms/v1.0#send_a_message|responses_&amp;_errors for more details.
    */
    'messageErrorCode': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "to",
            "baseName": "to",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reference",
            "baseName": "reference",
            "type": "string"
        },
        {
            "name": "parts",
            "baseName": "parts",
            "type": "number"
        },
        {
            "name": "messageDetails",
            "baseName": "messageDetails",
            "type": "string"
        },
        {
            "name": "messageErrorCode",
            "baseName": "messageErrorCode",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return MessageResponse.attributeTypeMap;
    }
}

/**
* The message(s) to send
*/
export class Messages {
    /**
    * Required: This contains the product token for authentication.
    */
    'authentication': Authentication;
    /**
    * Required. The msg-object signals a message and should comprise of at least a from, to and body-tag. One HTTP-call can support up to 1000 msg objects.
    */
    'msg': Array<Message>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "authentication",
            "baseName": "authentication",
            "type": "Authentication"
        },
        {
            "name": "msg",
            "baseName": "msg",
            "type": "Array<Message>"
        }    ];

    static getAttributeTypeMap() {
        return Messages.attributeTypeMap;
    }
}

/**
* Response from a Message POST
*/
export class MessagesResponse {
    /**
    * Human readable text such as: Created 1 message(s)
    */
    'details': string;
    /**
    * The error code, see https://docs.cmtelecom.com/bulk-sms/v1.0#send_a_message|responses_&amp;_errors for more details.
    */
    'errorCode': number;
    /**
    * Detailed information per message
    */
    'messages': Array<MessageResponse>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "details",
            "baseName": "details",
            "type": "string"
        },
        {
            "name": "errorCode",
            "baseName": "errorCode",
            "type": "number"
        },
        {
            "name": "messages",
            "baseName": "messages",
            "type": "Array<MessageResponse>"
        }    ];

    static getAttributeTypeMap() {
        return MessagesResponse.attributeTypeMap;
    }
}

/**
* Contains the  mobile number in international format.
*/
export class Recipient {
    /**
    * Required. This is the destination mobile number.   Restrictions: this value should be in international format. A single mobile number per request. Example: '00447911123456'
    */
    'number': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Recipient.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
}

let typeMap: {[index: string]: any} = {
    "Authentication": Authentication,
    "Message": Message,
    "MessageBody": MessageBody,
    "MessageEnvelope": MessageEnvelope,
    "MessageResponse": MessageResponse,
    "Messages": Messages,
    "MessagesResponse": MessagesResponse,
    "Recipient": Recipient,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }

    productToken: string;
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }

    productToken: string;
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }

    productToken: string;
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }

    productToken: string;
}

export enum MessagesApiApiKeys {
}

export class MessagesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MessagesApiApiKeys, value: string) {
        (this.authentications as any)[MessagesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary CM's Bulk SMS Gateway enables you to send text messages to mobile phones all around the world in very high volume.                            The Bulk SMS Gateway API covers the interface between your application and the CM Platform by means of the HTTP protocol. Only bulk (free of charge for the end user) text messages are supported.
     * @param message 
     */
    public messagesSendMessage (message: MessageEnvelope) : Promise<{ response: http.ClientResponse; body: MessagesResponse;  }> {
        const localVarPath = this.basePath + '/v1.0/message';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'message' is not null or undefined
        if (message === null || message === undefined) {
            throw new Error('Required parameter message was null or undefined when calling messagesSendMessage.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(message, "MessageEnvelope")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: MessagesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MessagesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
